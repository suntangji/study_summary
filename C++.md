1. 迭代器失效
    1) vector
        插入不需要扩容时，插入位置之后的迭代器失效，需要扩容时全部失效
    2) list
        被删除的结点迭代器失效
    3) 如何防止迭代器失效
        iter = container.erase(iter);
        使用原来的迭代器接收删除后返回的迭代器

2. 智能指针
    1) auto_ptr(C++98 引入,C++11 已弃用)
        转移所有权，一块空间只能被一个智能指针管理，拷贝赋值操作会进行所有权的转移。
        问题: 所有权转移后不能使用原智能指针访问空间，否则会段错误。
    2) unique_ptr
        独享所有权，通过禁用拷贝构造函数和赋值运算符重载禁止所有权的转移，试图转移编译器会报错。
    3) shared_ptr
        使用引用计数机制
        问题: 循环引用，解决: 使用 weak_ptr

3. 指针和引用的区别
    1) 引用是别名，指针是一个实体，需要分配内存空间，而引用不需要
    2) 引用不可以为空，指针可以为空
    3) 引用定义时必须初始化，且不能改变。指针可以定义时不初始化，且初始化后可以改变
    4) 引用和指针 自增自减、 sizeof 操作符意义不同
    5) 指针可以多级，但引用只能有一级
    6) T& ==> T* const

4. map 的第二个模板参数传一个类，这个类没有默认构造函数会不会出错
    编译错误。当调用 operator[] 时，如果 map 中没有这个 key 时，他会它会自动构造一
    个 pair 元素插进去，构造这个元素时就会调用 value 的默认构造函数，如果没有就会在编译时报
    构造函数找不到的错误。

5. 虚表属于类还是对象，虚表存在哪里
    虚表属于类，保存在只读数据段，虚表指针属于对象

6. 虚函数表在什么时候生成，构造函数前，中还是后
    虚函数表在编译期间生成，虚表指针在构造函数中初始化

7. 构造函数或析构函数能不能为虚函数？他们内部能不能调虚函数
    构造函数不可以为虚函数，因为虚表指针在构造函数中初始化，析构函数可以为虚函数，他们都可以调用虚函数，但是不建议这么做。

8. 仿函数和函数指针的区别
    仿函数(functor)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。
    1) 仿函数可以拥有成员函数和成员变量，所以仿函数拥有状态
    2) 仿函数拥有自己的型别，确保无法在排序规则不同的容器之间赋值、合并、或比较
    3) 仿函数比一般函数要快，作为模板参数一些行为在编译器就已确定
    4) 函数指针不能作为容器的模板参数，仿函数可以

9. 计算一个类实例化了多少个对象
    1) 使用静态成员变量，当调用构造函数时让变量自增    
    2) 如果还有一个类继承了这个类，怎么计算各自实例化了多少个对象
        派生类也定义一个静态变量，当派生类实例化时让派生类的静态变量自增，而基类的静态变量自减

10. new 和 malloc 的区别
    1) new 是关键字， malloc 是库函数
    2) 使用 new 不需要关心内存块大小，而 malloc 需要显示输入内存块大小
    3) 返回值不同， new 返回对象类型的指针，malloc 返回 void*
    4) 申请内存失败时，new 抛出 bad_alloc 异常，malloc 返回 NULL
    5) 