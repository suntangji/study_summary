1. 迭代器失效

    1) vector
        插入不需要扩容时，插入位置之后的迭代器失效，需要扩容时全部失效
    2) list
        被删除的结点迭代器失效
    3) 如何防止迭代器失效
        iter = container.erase(iter);
        使用原来的迭代器接收删除后返回的迭代器

2. 智能指针

    1) auto_ptr(C++98 引入,C++11 已弃用)
        转移所有权，一块空间只能被一个智能指针管理，拷贝赋值操作会进行所有权的转移。
        问题: 所有权转移后不能使用原智能指针访问空间，否则会段错误。
    2) unique_ptr
        独享所有权，通过禁用拷贝构造函数和赋值运算符重载禁止所有权的转移，试图转移编译器会报错。
    3) shared_ptr
        使用引用计数机制
        问题: 循环引用，解决: 使用 weak_ptr

3. 指针和引用的区别

    1) 引用是别名，指针是一个实体，需要分配内存空间，而引用不需要
    2) 引用不可以为空，指针可以为空
    3) 引用定义时必须初始化，且不能改变。指针可以定义时不初始化，且初始化后可以改变
    4) 引用和指针 自增自减、 sizeof 操作符意义不同
    5) 指针可以多级，但引用只能有一级
    6) T& ==> T* const

4. map 的第二个模板参数传一个类，这个类没有默认构造函数会不会出错

    编译错误。当调用 operator[] 时，如果 map 中没有这个 key 时，他会它会自动构造一
    个 pair 元素插进去，构造这个元素时就会调用 value 的默认构造函数，如果没有就会在编译时报
    构造函数找不到的错误。

5. 虚表属于类还是对象，虚表存在哪里

    虚表属于类，保存在只读数据段，虚表指针属于对象

6. 虚函数表在什么时候生成，构造函数前，中还是后

    虚函数表在编译期间生成，虚表指针在构造函数中初始化

7. 构造函数或析构函数能不能为虚函数？他们内部能不能调虚函数

    构造函数不可以为虚函数，因为虚表指针在构造函数中初始化，析构函数可以为虚函数，他们都可以调用虚函数，但是不建议这么做。

8. 仿函数和函数指针的区别

    仿函数(functor)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。
    1) 仿函数可以拥有成员函数和成员变量，所以仿函数拥有状态
    2) 仿函数拥有自己的型别，确保无法在排序规则不同的容器之间赋值、合并、或比较
    3) 仿函数比一般函数要快，作为模板参数一些行为在编译器就已确定
    4) 函数指针不能作为容器的模板参数，仿函数可以

9. 计算一个类实例化了多少个对象

    1) 使用静态成员变量，当调用构造函数时让变量自增    
    2) 如果还有一个类继承了这个类，怎么计算各自实例化了多少个对象
        派生类也定义一个静态变量，当派生类实例化时让派生类的静态变量自增，而基类的静态变量自减

10. new 和 malloc 的区别

    1) new 是关键字， malloc 是库函数
    2) 使用 new 不需要关心内存块大小，而 malloc 需要显示输入内存块大小
    3) 返回值不同， new 返回对象类型的指针，malloc 返回 void*
    4) 申请内存失败时，new 抛出 bad_alloc 异常，malloc 返回 NULL
    5) new 不仅仅分配内存，还会调用构造函数进行初始化，malloc 仅进行内存分配
    6) new 从自由存储区分配内存，malloc 从堆上分配内存。自由存储区取决于 operator new 的实现，可以是堆，也可以是静态存储区

11. C 和 C++ 的区别

    1) C 语言是面向过程的， C++ 是面向对象的
    2) 关键字个数和部分关键字含义不同
    3) C 语言中没有显式定义返回值默认是 int, C++ 必须定义返回值类型
    4) C 语言参数列表为空可以接收任意个参数， C++ 表示没有参数
    5) C++ 参数列表可以有缺省值， C 语言不支持
    6) C++ 可以函数重载， C 语言不可以
    7) C 语言定义结构体必须使用 struct 关键字， C++ 可以省略

12. 析构函数可以是纯虚函数吗

    可以，当一个抽象类实在没有成员可以定义为纯虚函数时，可以把虚构函数定义为纯虚函数。但是需要定义纯虚析构函数的函数体，否则编译器会报错

13. 内联函数和宏的区别

    1) 宏是用 #define 定义的，只是简单的替换，不能检查参数，没有返回值，有安全隐患
    2) 内联函数是使用 inline 定义的函数，取消了函数压栈，在调用时展开，减少了调用开销
    3）内联函数可以像普通函数一样有参数检查、返回值，可以调试,没有安全隐患
    4) inline 只是建议型关键字，使用 inline 编译器也不一定当作内联函数，如果函数体过长，有复杂的循环，编译器也会把它当作普通函数

14. 堆和栈的区别

    1) 在 C/C++ 中，栈由系统自动分配，堆需要程序员手动分配
    2) 在栈上申请和释放较快，在堆上申请效率没有栈上高，因为需要遍历空闲链表
    3) 栈较小，一般只有几兆，Windows 下一般为 1M, Linux 下默认为 8M,可以使用 ulimit -s 设置。堆较大，大小取决于内存
    4) 栈是向下(低地址)增长，堆是向上增长
    5) 栈上内存不够时，抛出 stackoverflow 异常， 堆上内存不够时，抛出 bad_alloc 异常
    6) 在数据结构中，栈是一种先进后出的数据结构，堆是父子结点有序的完全二叉树

15. malloc 原理

    glibc 使用的是 ptmalloc 的方式管理内存。对于大于 128k 的内存，使用 mmap 的方式进行内存映射，小于 128k 的内存，使用 brk 或 sbrk 系统调用获取内存。在系统中，有一个 break 指针， 用来标记已经进行内存映射的空间，访问一个没有进行内存映射的空间是非法的。要想开辟空间只需要移动 break 指针即可。有两个系统调用可以操作 break 指针，它们分别是 int brk(void* addr), void* sbrk(intptr_t increment)。brk 调用用于设置 break 指针为某个地址， sbrk 调用用于 break 指针增长。brk 和 sbrk 实现了空间的分配，但是每次移动 break 指针效率太低。为了提高效率，ptmalloc 预先向系统申请一块空间，并把申请的内存划分为块，又把内存块划分为 meta 区和数据区，meta 区存储数据区大小、空闲标志位、数据区起始地址等等，并用一个双向链表连接所有的内存块。每次调用 malloc 申请空间就遍历双向链表寻找大小合适的内存块，返回内存块数据区的起始地址。寻找内存块又有 first fit 和 best fit 两种方法，第一种效率高，内存碎片多，第二种效率低，内存碎片少。
    ptmalloc 的缺点:
        - 后申请的内存先释放(要释放 top chunk，需要释放相邻的 chunk)
        - 多线程加锁开销大
        - 多线程容易造成空间浪费(分为主分配区和次分配区)
        - 长生命周期容易出现内存碎片

16. 多态

    多态就是一个接口，多种方法，程序在运行时才决定调用哪个函数。在 C++ 中，多态分为静态多态和动态多态，静态多态发生在编译器，分为函数重载和泛型编程。动态多态发生在运行期，基类必须有虚函数，派生类必须重写了该虚函数，必须使用基类的指针或引用去调用虚函数，才会发生动态绑定。动态多态使用虚函数机制实现，编译器会为每个有虚函数的类生成一张虚函数表，该表存放在只读数据段，每个对象都有一个虚表指针，在构造函数中，会初始化虚表指针，把虚表指针指向虚函数表，虚表指针存在该对象模型的低地址处。派生类会继承基类的虚函数表，如果重写了虚函数，就替换对象虚函数表中相应函数的地址，如果增加了新的虚函数，也会依次添加到虚函数表中。

17. 哪些函数不可以为虚函数

    1) 普通函数，虚函数需要是类的成员函数
    2) 友元函数，友元函数不属于类
    3) 构造函数，虚函数需要对象调用，调用构造函数之前是没有对象的
    4) 内联函数，内联函数会在编译期展开，而虚函数需要在运行时绑定
    5) 静态成员函数，静态函数在编译时确定，而虚函数需要运行时确定