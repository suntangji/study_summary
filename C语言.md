1. 结构体对齐
    1) 对齐原因
        - 平台原因(移植原因):
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

        - 性能原因: 为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
    2) 对齐规则      
        1. 第一个成员在与结构体变量偏移量为0的地址处。
        2. 其他成员变量要对齐到对齐数的整数倍的地址处。
            对齐数 = 编译器默认对齐数 与 该成员大小的较小值。
            默认对齐数: 32 位操作系统为 4，64 位操作系统为 8
            修改默认对齐数: #pragma pack(n)
        3. 结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。
    3) 查看结构体偏移量
        使用宏 offsetof
        #define offsetof(type, member) (size_t)&(((type*)0)->member)

2.  
