1. 红黑树的性质

    1) 每个结点或是红色的，或是黑色的
    2) 根节点是黑色的
    3) 每个叶节点是黑色的
    4) 如果一个结点是红色的，它的叶子结点是黑色的
    5) 对每个结点，到它子节点的路径上包含相同数量的黑色结点

2. 红黑树和哈希的比较

    1) 红黑树存储的元素是有序的，哈希是无序的
    2) 红黑树的查找是 O(logn), 哈希是 O(1)
    3）红黑树的插入有满足二叉搜索树的规则，哈希要满足哈希函数的规则
    4) 红黑树的空间利用率更高，哈希的空间利用率低
    5) 如果想得到一个有序序列，使用红黑树，如果不关心序列的有序无序，查找操作更多使用哈希

3. 二叉搜索树

    它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

4. 哈希

    hash 也叫散列，是一种把不同长度的输入通过哈希函数转换为固定长度的输出的消息摘要函数。
    哈希的应用加密，数字签名，哈希表。常见的哈希加密算法， MD5， SHA1
    通过哈希函数把键值和键的地址关联起来的数据结构叫哈希表，常见的哈希函数
    直接定址法，平方取中法，随机数法，除留余数法
    处理冲突
        - 开放定址法(闭散列)
            如果冲突寻找下一个位置，又可以线性探测，二次探测，线性探测有数据堆积问题，二次探测有探测次数可能过多问题
        - 再哈希法
            构造多个不同的哈希函数
        - 链地址法
        - 建立公共溢出区

5. B 树和 B+ 树的区别

    这都是由于B+树和B具有这不同的存储结构所造成的区别，以一个m阶树为例。
    1) 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
    2) 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
    3) 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。
    4) 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。

6. 稳定的排序算法

    1) 冒泡排序
    2) 插入排序
    3) 归并排序
    4) 基数排序

7. 排序算法的复杂度

    排序算法 | 时间复杂度(平均) | 时间复杂度(最好) | 时间复杂度(最坏) | 空间复杂度
    --- | --- | --- | --- | ---
    冒泡排序 | O($ n^2 $) | O(n) | O($ n^2 $) | O(1)
    快速排序 | O(n $log_2$n) | O(n $log_2$n) | O($n^2$) | O($log_2$n) - O(n)
    插入排序 | O($ n^2 $) | O(n) | O($ n^2 $) | O(1)
    希尔排序 | O($ n^1.5 $) | O(n) | O($ n^2 $) | O(1)
    选择排序 | O($ n^2 $) | O($ n^2 $) | O($ n^2 $) | O(1)
    堆排序 | O(n $log_2$n) | O(n $log_2$n) | O(n $log_2$n) | O(1)
    归并排序 | O(n $log_2$n) | O(n $log_2$n) | O(n $log_2$n) | O(1)

8. 链表和数组的区别

    1) 数组是连续的内存，链表的内存是不连续的
    2) 数组支持随机访问，链表不支持随机访问
    3) 数组的任意位置插入、删除需要移动大量元素，而链表不需要移动元素，只需要改变指针的指向
    4) 数组定义需要指定大小，扩容时需要拷贝所有元素，而链表不需要指定大小，扩容方便
    5) 数组的空间利用率没有链表高

9. 哈夫曼树

    哈夫曼树是带权路径长度最短的树

10. 二叉树的性质

    1、若规定根节点的层数为 1，则一棵非空二叉树的第 i 层上最多有 $2^{i-1} (i>=1) $个结点
    2、若规定只有根节点的二叉树的深度为1，则深度为K的二叉树的最大结点数是 $ 2^k-1(k>=0) $
    3、对任何一棵二叉树, 如果其叶结点个数为 $ n_0 $, 度为2的非叶结点个数为 $ n_2 $,则有$ n_0$＝$n_2$＋1
    4、具有 n 个结点的完全二叉树的深度 k 为 $ log_2(n+1) $上取整。

11. n 个结点可以生成多少种二叉树

    1 个 结点生成 1 种
    2 个 结点生成 2 种
    3 个 结点生成 5 种
    4 个 结点生成 14 种
    n 个 结点生成
    $$ \frac {(2n)!}{(n!)(n+1)!} $$
    
12. 什么是排序的稳定性
    
    对于相同的关键字，在排序前后关键字的相对位置不变就是稳定的排序，否则就是不稳定的。

13. 快排什么时候最差

    待排序的数字基本有序，退化为冒泡排序。

14. 快速排序原理

    1) 左右指针
        快排是找一个基准值，让基准值左边的元素都小于基准值，基准值右边的元素都大于基准值。先先一个基准值，一半为第一个元素，如果为升序，在序列最右边选一个小于基准值的数，在序列左边选一个大于基准值的数，然后再去寻找第二组，直到左边索引等于右边索引，然后把基准值和左边索引交换，叫完成了一次快速排序。然后对基准值左边和右边分别进行快排，整个数列就有序了。

    2) 挖坑法
        letf 为左边开始的索引，right 为右边开始的索引，先保存最左边元素为基准值，然后在最右边找一个小于基准值的元素，把这个元素存在存在 letf 所对应的位置，left++,这样最右边就空出一个空位，在左边找一个大于基准值的元素，存在 right 对于的位置，right--，直到 left == right，最后一个空位存储基准值，一次快排完成，然后对基准值左边元素快排，右边元素快排，最后整体有序

    3) 前后指针
        基准值为 right 对应的元素，使用前后两个索引 prev 和 cur，prev = left -1,cur = left,只要 cur < right , 并且 cur 对应的元素小于基准值， prev++,如果prev != cur, 交换 prev 和 cur 对应的值，cur++,prev 对应的值一定大于基准值， cur 对应的值一定小于基准值，直到 cur = right,交换 cur 和 prev,也就是交换基准值和大于基准值的元素，一次快排完成
        ``` C
        int partion(int arr[], int left, int right) {
	        if (left < right) {
		        int key = arr[right];
		        int prev = left - 1;
		        int cur = left;
		        while (cur < right) {
			        while (arr[cur] < key && ++prev != cur) {
				    std::swap(arr[cur], arr[prev]);
			        }
			        ++cur;
		        }
		        std::swap(arr[++prev], arr[right]);
		        return prev;
	        }
	        return -1;
        }
        ```

15. 归并排序原理

    归并排序的思想是合并两个有序的序列。使用一个临时空间存储归并后的序列，最后将归并好的序列拷贝回原数组，找到序列的中间元素，然后归并中间元素左边的序列，在归并中间元素右边的序列，然后进行递归，直到序列中只有一个元素，那一定是有序的，然后把两个有序序列进行归并到临时空间，再把临时空间的元素拷贝到待排序的序列，就完成了一次归并，然后返回去归并中间元素的左边，然后归并右边，最后归并好整个序列。

16. 最小生成树

    - 普里姆
    - 克鲁斯卡尔